    //DTO -> DMO merging

    public <T extends UuidHolder, S extends UuidHolder> Set<S> mergeSet(final Set<T> source,
        Set<S> target, final Merger<T, S> merger, final MapContext context) {

        final Map<String, S> beforeItems = new HashMap<>();

        if (target == null) {
            target = new HashSet<>();
        }
        if (source == null) {
            return target;
        }

        for (S oldItem : target) {
            final String key = oldItem.getUuid();
            beforeItems.put(key, oldItem);
        }

        final Map<String, S> afterItems = new HashMap<>();

        for (T sourceItem : source) {
            if (sourceItem != null) {
                final String key = sourceItem.getUuid();
                afterItems.put(key, merger.merge(sourceItem, beforeItems.get(key), context));
            }
        }

        getRemovedItems(beforeItems, afterItems).forEach(target::remove);
        getNewItems(beforeItems, afterItems).forEach(target::add);

        return target;
    }


    //interface for generic mapSet method calls
    public interface Mapper<TS, TT> {

        TT map(TS source, MapContext context);

    }

    public interface Merger<TS, TT> {

        TT merge(TS source, TT target, MapContext context);
    }

    //generic methods
    public <TS, TT> Set<TT> mapSet(final Set<TS> sourceCollection, final Mapper<TS, TT> mapper,
        MapContext context) {
        final Set<TT> targetCollection = new HashSet<>();
        if (CollectionUtils.isEmpty(sourceCollection)) {
            return targetCollection;
        }
        targetCollection.addAll(sourceCollection.stream().map(ts -> mapper.map(ts, context))
            .collect(Collectors.toList()));
        return targetCollection;
    }

    private <T> Collection<T> getNewItems(final Map<String, T> beforeItems,
        final Map<String, T> afterItems) {
        final Set<T> result = new HashSet<>();
        final Set<String> beforeKeys = beforeItems.keySet();
        for (Map.Entry<String, T> afterEntry : afterItems.entrySet()) {
            if (!beforeKeys.contains(afterEntry.getKey())) {
                result.add(afterEntry.getValue());
            }
        }
        return result;
    }

    private <T> Collection<T> getRemovedItems(final Map<String, T> beforeItems,
        final Map<String, T> afterItems) {
        final Set<T> result = new HashSet<>();
        final Set<String> afterKeys = afterItems.keySet();
        for (Map.Entry<String, T> beforeEntry : beforeItems.entrySet()) {
            if (!afterKeys.contains(beforeEntry.getKey())) {
                result.add(beforeEntry.getValue());
            }
        }
        return result;
    }
